---
layout: post
title:  ALSA（二）, WebSocket, Javascript在客户端的使用, Spring, Neo4j, Blog维护日志
category: technology 
---

# 从Gstreamer到ALSA（续）

## 4.SOC_SINGLE类宏

这里对SOC_SINGLE类的宏，详细说明一下，因为只有这些宏才是真正需要驱动开发者添加或修改的。

例如如下的代码：

{% highlight c %}
SOC_DOUBLE_R_TLV("Digital Playback Volume", JZCODEC_DACLVOL, JZCODEC_DACRVOL,
		 0, 255, 0, jzcodec_tlv),
{% endhighlight %}

使用amixer命令观察该代码的效果：

{% highlight bash %}
Simple mixer control 'Digital',0
  Capabilities: pvolume
  Playback channels: Front Left - Front Right
  Limits: Playback 0 - 255
  Mono:
  Front Left: Playback 255 [100%] [0.00dB]
  Front Right: Playback 255 [100%] [0.00dB]
{% endhighlight %}

从中可以看出snd_kcontrol_new的name成员的名字是有特定含义的，不能随便定。

有的音频芯片，如TAS5086，它的音量寄存器用0xFF表示静音，而用0x0表示最大音量，这种情况下需要将SOC_SINGLE类宏的invert参数设为1。

## 5.SOC_SINGLE_TLV类宏

除了SOC_SINGLE类宏之外，还有SOC_SINGLE_TLV类宏。后者和前者的主要区别在于：用TLV数组完成音量到寄存器值之间的转换。

例如如下代码：

{% highlight c %}
static const DECLARE_TLV_DB_SCALE(tas5086_dac_tlv, -10350, 50, 1);
{% endhighlight %}

-10350是音量的最小值，表示-103.5dB。50是相邻的两个寄存器值之间的音量差（即步长），这里表示0.5dB。也就是说这个宏设定的音量值的单位都是0.01dB。

# ASOC对多Codec的支持

## 音频设计方案

ASOC在Linux 3.X时代最大的改进就是添加了对多codec的支持。这里我们首先描述一下多Codec在音频设备设计中的意义，以及它的一些实现方案。

![](/images/article/multi_codec_0.png)

上图是实现方案A，它的特点是：

1.1个MCU通过2个Codec，间接连接了4个Speaker。在当前的音频设计中，音箱的扬声器个数越来越多，但是单个Codec所能提供的声道数量有限。当扬声器个数超过这一数量限制时，就需要采用多Codec方案了。

2.两个Codec有独立的I2C控制通道。这里的“独立”是逻辑意义上的。在物理上，两个Codec可挂在同一条I2C总线上，以不同的从机地址加以区分。

3.两个Codec共享I2S输入。

![](/images/article/multi_codec_1.png)

上图是实现方案B，它和方案A的区别为：两个Codec有独立的I2S输入。方案B根据用途，又可分为两种子方案：

1.方案B1：两个I2S的输入相同。

2.方案B2：两个I2S的输入不同。

## 方案A的代码实现

1.首先讨论I2C控制的实现，这里以TAS5731M芯片为例。

在board初始化阶段，为两个codec各自生成一个I2C设备。

{% highlight c %}
static struct i2c_board_info __initdata rtl819xd_i2c_devices[] = {
	{
		I2C_BOARD_INFO("tas5731", 0x1a), //TAS5731M Master
	},
	{
		I2C_BOARD_INFO("tas5731", 0x1b), //TAS5731M Sub
	},
};
{% endhighlight %}

2.方案A由于共享I2S，因此在驱动角度，必须将两个codec驱动整合到一个card之中。

相应的machine代码为：

{% highlight c %}
static struct snd_soc_dai_link rtl819xd_jzcodec_dai[] = {
	{
		.name = "JZCODEC_MASTER",
		.stream_name = "JZCODEC_MASTER",
		.cpu_dai_name = "rtl8197d-i2s",
		.codec_name = "tas5731.0-001a",
		.codec_dai_name = "tas5731_master",
		.init = rtl819xd_jzcodec_jzcodec_init,
		.ops = &rtl819xd_jzcodec_ops,
		.platform_name	= "rtl819x-pcm-audio",
	},
	{
		.name = "JZCODEC_SUB",
		.stream_name = "JZCODEC_SUB",
		.cpu_dai_name = "rtl8197d-i2s",
		.codec_name = "tas5731.0-001b",
		.codec_dai_name = "tas5731_sub",
		.init = rtl819xd_jzcodec_jzcodec_init,
		.ops = &rtl819xd_jzcodec_ops,
	}
};
{% endhighlight %}

相应的codec代码为：

{% highlight c %}
static struct snd_soc_dai_driver tas5731_dai[] = {
	{
		.name = "tas5731_master",
		.id = 0,
		.playback = {
			.stream_name	= "Playback",
			.channels_min	= 2,
			.channels_max	= 6,
			.rates		= TAS5731_PCM_RATES,
			.formats	= TAS5731_PCM_FORMATS,
		},
		.ops = &tas5731_dai_ops,
	},
	{
		.name = "tas5731_sub",
		.id = 1,
		.playback = {
			.stream_name	= "Playback",
			.channels_min	= 2,
			.channels_max	= 6,
			.rates		= TAS5731_PCM_RATES,
			.formats	= TAS5731_PCM_FORMATS,
		},
		.ops = &tas5731_dai_ops,
	}
};
{% endhighlight %}

这里对代码的要点做一个解释：

1）codec_name的命名规则。codec_name一般以X.Y-Z的形式命名。

其中X为codec的I2C driver名称。注意这里的名称和I2C_BOARD_INFO中定义的名称不同，后者是根据i2c_device_id中定义的名称来命名的。只是在这个例子中，两者恰好是一致的。

Y表示I2C总线号。如果MCU有超过一条I2C总线的话，需要使用总线号加以区分。

Z表示Codec设备的从机地址。

2）由于两个Codec共享I2S输入，因此只需要其中一个Codec定义platform_name即可。

## 方案B1的代码实现

和方案A的差别在于：两个Codec都需要定义自己的platform_name。

## 方案B2的代码实现

这种情况用两个独立的card来解决就可以了。

# WebSocket

在浏览器中通过http仅能实现单向的通信。AJAX通过轮询方式，达到全双工通信，但效率不高。

面对这种状况，HTML5定义了WebSocket协议（基于TCP），能更好的节省服务器资源和带宽并达到实时通讯。

浏览器请求

{% highlight text %}
GET /webfin/websocket/ HTTP/1.1
　　Host: localhost
　　Upgrade: websocket
　Connection: Upgrade
　　Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==
　　Origin: http://www.sohu.com
　　Sec-WebSocket-Version: 13
{% endhighlight %}

服务器回应

{% highlight text %}
HTTP/1.1 101 Switching Protocols
　　Upgrade: websocket
　　Connection: Upgrade
　　Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=
{% endhighlight %}

# Javascript在客户端的使用

Javascript在服务器前端的成功，促使人们思考其在客户端的使用。

最早的尝试，是MS提供的web broswer控件（例如MFC的CHtmlView类）。然而，当时的目的，并不是美化应用程序外观，而只是给程序提供一个访问互联网的机会。其最常见的用处，就是给About添加一个网站链接。这种方式不光用途简陋，更关键的是从外观来看，网页和应用程序完全是两种风格。

网站的外观在随后的几年中进化的很快，由于CSS和Javascript的出现，网页前端不再是一成不变的静态网页，而是具有了一定的动画和交互能力。强大的功能促进了分工的发展，网站设计逐渐分成了前端和后端两大工种。这种分工又促进了网页交互技术的进步。

反观普通的应用程序，由于受限于编程的复杂度，前端人员一直难于介入，很多年都处于停滞阶段。这期间一些不甘平庸的公司，在UI技术方面也做了一些尝试。

首先是DirectUI。这个是MS对于Win32窗口模型的一个重大改进。

在原始的Win32窗口模型中，每个控件都是一个窗口，拥有一个窗口句柄（相当于窗口资源的描述符）。窗口事件的处理和资源管理都在OS层面进行，开销比较大。（比如包含10000个按钮的窗口怎么处理的问题）窗口之间的交互，比如透明、动画，也由于需要跨窗口句柄，而变得非常复杂。

DirectUI的思路，是将控件降级为贴图，并接管整体窗口事件的处理，以模拟的方式实现控件的行为。开销和扩展性得到了很大的提升。

DirectUI技术最早出现在Windows XP中。比如，“我的电脑”左侧的控制面板。由于它的HWND的名字叫做DirectUI，故名。GTK项目实际上也采用了类似的方案。

DirectUI技术国内做的比较好的有:

https://www.douban.com/group/topic/27583755/

各种DirectUI技术，普遍引入了UI配置文件的概念，而且UI配置文件的功能也越来越强。比如，GTK的设计器Glade，早期的时候是根据UI设计，导出代码，但现在已经改为导出UI配置文件了。

然而，由于低层实现的限制，这些UI配置文件语法各异，虽然有设计器来简化设计难度，但注定不能做的太复杂。因此，功能上无论如何都无法与网页相比，更不必说和HTML 5相比了。

2012年以后，以CEF（Chromium Embedded Framework）和XULRunner为代表的浏览器派，开始逐渐崭露头角。从此，开发桌面应用程序，不再是Javascript的禁区。桌面应用UI和网页前端开始呈现融合的局面。

# Spring

Spring是一个Java Web应用框架。官网：

http://spring.io/

## Ubuntu安装Eclipse、Spring

1.安装Eclipse

`sudo apt-get install eclipse`

2.安装Spring

`sudo apt-get install libspring-web-portlet-java`

注意：ubuntu软件仓库中还有一个叫做spring的游戏引擎，不要弄错了。

http://www.mkyong.com/spring/quick-start-maven-spring-example/

http://wiki.jikexueyuan.com/project/spring/

## Restful

http://spring.io/guides/gs/rest-service/

## Spring Boot

https://www.tianmaying.com/tutorial/deploy-spring-boot-application

http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html

Spring Boot默认的配置文件

## WebService

https://spring.io/guides/gs/producing-web-service/

http://localhost:9999/ws/countries.wsdl

# Neo4j

Neo4j是一个高性能的图引擎，该引擎具有成熟和健壮的数据库的所有特性。相对于关系数据库来说，图数据库（Graph Database）善于处理大量复杂、互连接、低结构化的数据，这些数据变化迅速，需要频繁的查询——在关系数据库中，这些查询会导致大量的表连接，因此会产生性能上的问题。

官网：

https://neo4j.com/

参考：

http://blog.csdn.net/xingxiupaioxue/article/details/71747284

如何将大规模数据导入Neo4j

# Blog维护日志

2017.12.21 blog图片太多，特添加第2个图片文件夹。

2017.10.22 文章分为Language、Linux、Technology、Essay、Resource、Graphics、AI、ML、Math、DL十类。可命名为v3.5。

2017.10.18 文章数达到150篇。

2017.5.17 修改标题的css。可命名为v3.0。

2017.4.5 添加微信打赏二维码图片。

2017.3.22 评论系统切换到Github Issue。

2017.3.4 文章数达到100篇。

2016.11.3 文章分为Technology、Theory、Essay三类。

2016.8.1 添加blog数量的统计信息，将MathJax升级到2.6.1。

2016.4.12 将MathJax等资源切换为国内的cdn。

2016.4.10 首页将技术文章和非技术文章分栏显示。

2016.3.30 白底黑字太晃眼，特切换为浅灰底色。

2016.3.18 评论系统切换到多说。

2016.2.22 文章数达到50篇。

2016.2.2 代码区的配色实在看起来费眼，屡次微调，仍不满意。这次借鉴原blog（也就是大徐抄袭的源头）的配色方案，最终达到基本满意的效果。可命名为v2.0。

2015.1.7 blog搬家基本完成。

2014.12.23 围观大徐的blog有感，特在github上安家落户，废弃了原来的搜狐blog。

