---
layout: post
title:  网络杂谈, ASOC对多Codec的支持
category: technology 
---

# 网络杂谈

## 集线器&交换机&路由器

1.集线器，又名HUB。一般只起增强信号的作用，并不对流经的数据进行处理。数据转发采用广播方式，只适合少量终端设备的情况。

2.交换机。它会对转发数据的数据链路层（OSI第二层）进行处理。

2.路由器。它会对转发数据的网络层（OSI第三层）进行处理。

以上都是一些原始定义，实际情况中，由于都是网络数据交换设备，跨界的情况随着硬件的升级，而屡见不鲜。比如现在的集线器，多数也有简单的数据处理能力；而现在的交换机，有的也有第三层处理能力（比如三层交换机）。

以我的经历为例，2003年左右，大学宿舍的兄弟们就使用集线器，进行联网游戏。

2007年，换用交换机，和合租的同事，一起上网。

2010年，换用无线路由器，手机也可以wifi上网了。

## XMPP

XMPP(Extensible Messaging Presence Protocol)和SIP(Session Initiation Protocol)都是应用层的数据交换协议。作为它们前辈的HTTP虽然取得很大成功，但也存在如下问题：

1.内容形式主要限定为html，对于传输非界面数据的应用来说，效率不高，也不专业。

2.HTTP基于Client发送请求，Server响应的模式。对于VOIP这样的应用来说，Server主动发送数据的能力显然更关键。

XMPP和SIP的特点如下表所示：

<table>
  <tr>
    <th width="20%"></th>
    <th width="40%">XMPP</th>
    <th width="40%">SIP</th>
  </tr>
  <tr>
    <td>核心协议的目的</td>
    <td>服务于结构化的数据交换</td>
    <td>服务于连接的建立</td>
  </tr>
  <tr>
    <td>核心外扩展</td>
    <td>添加Jingle协议支持面向连接的业务</td>
    <td>添加SIMPLE协议支持即时通信业务</td>
  </tr>
  <tr>
    <td>应用支持和扩展性</td>
    <td>优</td>
    <td>一般</td>
  </tr>
  <tr>
    <td>数据格式</td>
    <td>XML，易解析</td>
    <td>文本，不易解析。</td>
  </tr>
  <tr>
    <td>通道方式</td>
    <td>控制和数据通道是一体的，Clent只与Server建立连接，而Client与client之间是没有连接的。Client之间传送的通道是：Client1-->Server1-->Server2-->Client2。这种方式看起来扩展性差，Server压力很大，但是能够实现很好的业务功能，比如留言、广播、群聊、状态更新、Blog、微博、数据共享等等。</td>
    <td>连接建立通道与数据传送通道是各自独立的，连接建立在Client与Server之间，而数据传送通道是在Client-->Client之间直接进行的。这个对视频、语音和文件传送业务很合适，但是不适合其他形式的应用。</td>
  </tr>
  <tr>
    <td>底层协议</td>
    <td>TCP and TLS only</td>
    <td>UDP, TCP and TLS</td>
  </tr>
  <tr>
    <td>连接方式</td>
    <td>单向连接，只有Client可以向Server发起连接请求，Server不会向Client发起连接。这样便于NAT和firewall的穿越。</td>
    <td>双向对称，客户端和服务器都可以主动发起连接请求并响应，这种对称连接的方式在穿越NAT和firewall的时候，带来很大的复杂性，无法保证穿越NAT。</td>
  </tr>
  <tr>
    <td>前景</td>
    <td>开源实现众多，应用广泛。且被Google、MS、Facebook等巨头支持，前景乐观。</td>
    <td>核心外业务没有起色。核心业务也遭到Jingle协议的挑战。</td>
  </tr>
</table>

参考文献：

http://my.oschina.net/linuxhunter/blog/35370

基于loudmouth的XMPP客户端DEMO

http://xmpp.org/xmpp-software/

这个网页列出了XMPP的各种客户端、服务器以及库的实现。在我们的项目中，服务端使用Openfire，嵌入式客户端使用gloox。

## osip & eXosip

osip是SIP协议的一个开源实现。其官网为：

http://savannah.gnu.org/projects/osip

eXosip在osip上封装了一层，简化了在多媒体会话方面SIP协议的使用。其官网为：

http://savannah.nongnu.org/projects/exosip/

## UPNP

官方的协议规范：

http://www.upnp.org/specs/

参考资料：

http://www.h3c.com.cn/MiniSite/Technology_Circle/Net_Reptile/The_Five/Home/Catalog/201206/747039_97665_0.htm

这是H3C的一个系列教程中的一篇。

## NTP

Network Time Protocol，是用来让计算机之间实现时间同步的协议。

网上可用的NTP Server列表，可参见：

http://www.pool.ntp.org/en/

NTP的Client有很多，这里使用ntpclient软件。它的官网：

http://doolittle.icarus.com/ntpclient/

调试的时候，可以使用如下命令设置时间：

`sudo date -s 10:00:00`

修改之后，可用`date`命令查看系统当前时间，确认修改的效果。

ntpd是NTP的另一个实现，既可以当Server，也可以当Client，已经被集成进busybox。

# ASOC对多Codec的支持

## 音频设计方案

ASOC在Linux 3.X时代最大的改进就是添加了对多codec的支持。这里我们首先描述一下多Codec在音频设备设计中的意义，以及它的一些实现方案。

![](/images/article/multi_codec_0.png)

上图是实现方案A，它的特点是：

1.1个MCU通过2个Codec，间接连接了4个Speaker。在当前的音频设计中，音箱的扬声器个数越来越多，但是单个Codec所能提供的声道数量有限。当扬声器个数超过这一数量限制时，就需要采用多Codec方案了。

2.两个Codec有独立的I2C控制通道。这里的“独立”是逻辑意义上的。在物理上，两个Codec可挂在同一条I2C总线上，以不同的从机地址加以区分。

3.两个Codec共享I2S输入。

![](/images/article/multi_codec_1.png)

上图是实现方案B，它和方案A的区别为：两个Codec有独立的I2S输入。方案B根据用途，又可分为两种子方案：

1.方案B1：两个I2S的输入相同。

2.方案B2：两个I2S的输入不同。

## 方案A的代码实现

1.首先讨论I2C控制的实现，这里以TAS5731M芯片为例。

在board初始化阶段，为两个codec各自生成一个I2C设备。

{% highlight c %}
static struct i2c_board_info __initdata rtl819xd_i2c_devices[] = {
	{
		I2C_BOARD_INFO("tas5731", 0x1a), //TAS5731M Master
	},
	{
		I2C_BOARD_INFO("tas5731", 0x1b), //TAS5731M Sub
	},
};
{% endhighlight %}

2.方案A由于共享I2S，因此在驱动角度，必须将两个codec驱动整合到一个card之中。

相应的machine代码为：

{% highlight c %}
static struct snd_soc_dai_link rtl819xd_jzcodec_dai[] = {
	{
		.name = "JZCODEC_MASTER",
		.stream_name = "JZCODEC_MASTER",
		.cpu_dai_name = "rtl8197d-i2s",
		.codec_name = "tas5731.0-001a",
		.codec_dai_name = "tas5731_master",
		.init = rtl819xd_jzcodec_jzcodec_init,
		.ops = &rtl819xd_jzcodec_ops,
		.platform_name	= "rtl819x-pcm-audio",
	},
	{
		.name = "JZCODEC_SUB",
		.stream_name = "JZCODEC_SUB",
		.cpu_dai_name = "rtl8197d-i2s",
		.codec_name = "tas5731.0-001b",
		.codec_dai_name = "tas5731_sub",
		.init = rtl819xd_jzcodec_jzcodec_init,
		.ops = &rtl819xd_jzcodec_ops,
	}
};
{% endhighlight %}

相应的codec代码为：

{% highlight c %}
static struct snd_soc_dai_driver tas5731_dai[] = {
	{
		.name = "tas5731_master",
		.id = 0,
		.playback = {
			.stream_name	= "Playback",
			.channels_min	= 2,
			.channels_max	= 6,
			.rates		= TAS5731_PCM_RATES,
			.formats	= TAS5731_PCM_FORMATS,
		},
		.ops = &tas5731_dai_ops,
	},
	{
		.name = "tas5731_sub",
		.id = 1,
		.playback = {
			.stream_name	= "Playback",
			.channels_min	= 2,
			.channels_max	= 6,
			.rates		= TAS5731_PCM_RATES,
			.formats	= TAS5731_PCM_FORMATS,
		},
		.ops = &tas5731_dai_ops,
	}
};
{% endhighlight %}

这里对代码的要点做一个解释：

1）codec_name的命名规则。codec_name一般以X.Y-Z的形式命名。

其中X为codec的I2C driver名称。注意这里的名称和I2C_BOARD_INFO中定义的名称不同，后者是根据i2c_device_id中定义的名称来命名的。

Y表示I2C总线号。如果MCU有超过一条I2C总线的话，需要使用总线号加以区分。

Z表示Codec设备的从机地址。

2）由于两个Codec共享I2S输入，因此只需要其中一个Codec定义platform_name即可。

## 方案B1的代码实现

和方案A的差别在于：两个Codec都需要定义自己的platform_name。

## 方案B2的代码实现

这种情况用两个独立的card来解决就可以了。
