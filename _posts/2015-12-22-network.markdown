---
layout: post
title:  网络杂谈
category: technology 
---

# 网络杂谈

## 集线器&交换机&路由器

1.集线器，又名HUB。一般只起增强信号的作用，并不对流经的数据进行处理。数据转发采用广播方式，只适合少量终端设备的情况。

2.交换机。它会对转发数据的数据链路层（OSI第二层）进行处理。

2.路由器。它会对转发数据的网络层（OSI第三层）进行处理。

以上都是一些原始定义，实际情况中，由于都是网络数据交换设备，跨界的情况随着硬件的升级，而屡见不鲜。比如现在的集线器，多数也有简单的数据处理能力；而现在的交换机，有的也有第三层处理能力（比如三层交换机）。

以我的经历为例，2003年左右，大学宿舍的兄弟们就使用集线器，进行联网游戏。

2007年，换用交换机，和合租的同事，一起上网。

2010年，换用无线路由器，手机也可以wifi上网了。

## XMPP

XMPP(Extensible Messaging Presence Protocol)和SIP(Session Initiation Protocol)都是应用层的数据交换协议。作为它们前辈的HTTP虽然取得很大成功，但也存在如下问题：

1.内容形式主要限定为html，对于传输非界面数据的应用来说，效率不高，也不专业。

2.HTTP基于Client发送请求，Server响应的模式。对于VOIP这样的应用来说，Server主动发送数据的能力显然更关键。

XMPP和SIP的特点如下表所示：

<table>
  <tr>
    <th width="20%"></th>
    <th width="40%">XMPP</th>
    <th width="40%">SIP</th>
  </tr>
  <tr>
    <td>核心协议的目的</td>
    <td>服务于结构化的数据交换</td>
    <td>服务于连接的建立</td>
  </tr>
  <tr>
    <td>核心外扩展</td>
    <td>添加Jingle协议支持面向连接的业务</td>
    <td>添加SIMPLE协议支持即时通信业务</td>
  </tr>
  <tr>
    <td>应用支持和扩展性</td>
    <td>优</td>
    <td>一般</td>
  </tr>
  <tr>
    <td>数据格式</td>
    <td>XML，易解析</td>
    <td>文本，不易解析。</td>
  </tr>
  <tr>
    <td>通道方式</td>
    <td>控制和数据通道是一体的，Clent只与Server建立连接，而Client与client之间是没有连接的。Client之间传送的通道是：Client1-->Server1-->Server2-->Client2。这种方式看起来扩展性差，Server压力很大，但是能够实现很好的业务功能，比如留言、广播、群聊、状态更新、Blog、微博、数据共享等等。</td>
    <td>连接建立通道与数据传送通道是各自独立的，连接建立在Client与Server之间，而数据传送通道是在Client-->Client之间直接进行的。这个对视频、语音和文件传送业务很合适，但是不适合其他形式的应用。</td>
  </tr>
  <tr>
    <td>底层协议</td>
    <td>TCP and TLS only</td>
    <td>UDP, TCP and TLS</td>
  </tr>
  <tr>
    <td>连接方式</td>
    <td>单向连接，只有Client可以向Server发起连接请求，Server不会向Client发起连接。这样便于NAT和firewall的穿越。</td>
    <td>双向对称，客户端和服务器都可以主动发起连接请求并响应，这种对称连接的方式在穿越NAT和firewall的时候，带来很大的复杂性，无法保证穿越NAT。</td>
  </tr>
  <tr>
    <td>前景</td>
    <td>开源实现众多，应用广泛。且被Google、MS、Facebook等巨头支持，前景乐观。</td>
    <td>核心外业务没有起色。核心业务也遭到Jingle协议的挑战。</td>
  </tr>
</table>

参考文献：

http://my.oschina.net/linuxhunter/blog/35370

基于loudmouth的XMPP客户端DEMO

http://xmpp.org/xmpp-software/

这个网页列出了XMPP的各种客户端、服务器以及库的实现。在我们的项目中，服务端使用Openfire，嵌入式客户端使用gloox。

## osip & eXosip

osip是SIP协议的一个开源实现。其官网为：

http://savannah.gnu.org/projects/osip

eXosip在osip上封装了一层，简化了在多媒体会话方面SIP协议的使用。其官网为：

http://savannah.nongnu.org/projects/exosip/

## NTP

Network Time Protocol，是用来让计算机之间实现时间同步的协议。

网上可用的NTP Server列表，可参见：

http://www.pool.ntp.org/en/

NTP的Client有很多，这里使用ntpclient软件。它的官网：

http://doolittle.icarus.com/ntpclient/

调试的时候，可以使用如下命令设置时间：

`sudo date -s 10:00:00`

修改之后，可用`date`命令查看系统当前时间，确认修改的效果。

ntpd是NTP的另一个实现，既可以当Server，也可以当Client，已经被集成进busybox。

## UPNP

官方的协议规范参见：

http://www.upnp.org/specs/

![](/images/article/upnp_stack.png)

上图是UPNP的协议栈。详细的解释参见：

http://www.h3c.com.cn/MiniSite/Technology_Circle/Net_Reptile/The_Five/Home/Catalog/201206/747039_97665_0.htm

这是H3C的一个系列教程中的一篇。

## libupnp

libupnp是UPNP协议的一个实现库。它最早由英特尔开发并开源，是目前Linux平台最流行的实现库，其官网为：

http://pupnp.sourceforge.net/

![](/images/article/libupnp.png)

上图是libupnp体系结构图，其参考教程可参见：

http://blog.csdn.net/braddoris/article/details/41646789

这里仅对上文中的内容，做一个补充：

1.GENA协议规范

https://tools.ietf.org/id/draft-cohen-gena-p-base-01.txt

2.其他参考资料

http://max.book118.com/html/2014/0811/9385832.shtm

http://blog.csdn.net/hqyhqyhq/article/details/17921797

http://download.csdn.net/detail/liguangshou06/2685789

## libupnp示例详解

libupnp自带的示例在upnp/sample路径下。编译之后，可生成三个可执行文件：

1.tv_device。UPNP设备端实现，即UPNP的服务提供者。

2.tv_ctrlpt。UPNP控制端实现。

3.tv_combo。前两者的混合体。

实际测试使用中，可以同时运行tv_ctrlpt和tv_device，以观察两者之间的交互。

### tv_device代码流程详解

1.初始化

upnp/sample/linux/tv_device_main.c: main

upnp/sample/common/tv_device.c: device_main

upnp/sample/common/tv_device.c: TvDeviceStart

upnp/src/api/upnpapi.c: UpnpInit

upnp/src/api/upnpapi.c: UpnpInitStartServers

upnp/src/genlib/miniserver/miniserver.c: StartMiniServer

这是整个初始化过程中，最重要的函数。它负责创建Web Server和线程池。UPNP的所有功能都在这些线程（而不是主线程）中实现。

2.事件处理

事件处理分成两步

1）注册事件处理回调函数

upnp/src/api/upnpapi.c: TvDeviceStart

upnp/src/api/upnpapi.c: UpnpRegisterRootDevice

这一步向一个中间结构注册回调函数。

upnp/src/api/upnpapi.c: UpnpInitPreamble

这一步调用SetGenaCallback函数，将上一步注册到中间结构中的回调函数，注册到GENA事件处理线程中。

UpnpRegisterRootDevice有若干不同的变种：UpnpRegisterRootDevice2、UpnpRegisterRootDevice3、UpnpRegisterRootDevice4。其中，对于动态生成设备描述的方式来说，UpnpRegisterRootDevice2更好用一些。

2）事件处理流程

upnp/src/genlib/miniserver/miniserver.c: RunMiniServer

upnp/src/genlib/miniserver/miniserver.c: web_server_accept

upnp/src/genlib/miniserver/miniserver.c: schedule_request_job

这一步从线程池中启动一个线程来处理事件。

upnp/src/genlib/miniserver/miniserver.c: handle_request

upnp/src/genlib/miniserver/miniserver.c: dispatch_request

这一步根据事件类型进行分发。具体到GENA就是调用：

upnp/src/gena/gena_callback2.c: genaCallback

这一步根据角色的不同，调用gena_process_subscription_request（device）或gena_process_notification_event（control point）。

upnp/src/gena/gena_device.c: gena_process_subscription_request

这里会最终调用注册的事件处理函数。

### tv_ctrlpt代码流程详解

1.初始化

upnp/sample/linux/tv_ctrlpt_main.c: main

common/tv_ctrlpt.c: TvCtrlPointStart

upnp/src/api/upnpapi.c: UpnpInit

以下与tv_device相同。

2.注册客户端

common/tv_ctrlpt.c: TvCtrlPointStart

upnp/src/api/upnpapi.c: UpnpRegisterClient

其他部分与tv_device相同。

## gmediarender的UPNP流程详解

gmediarender使用libupnp库进行DLNA协议的交互。这个项目的难度中等，可作为libupnp库的进阶教程。由于大部分的内容和tv_device类似，因此，这里只列出差异的部分。

### 概述

MediaRenderer包含三个服务：

1)RenderingControl。代码在src/upnp_control.c中。

2)ConnectionManager。代码在src/upnp_connmgr.c中。

3)AVTransport。代码在src/upnp_transport.c中。

注意：MediaRenderer和所包含的服务都有版本的概念。比如MediaRenderer在XML中一般表示为`urn:schemas-upnp-org:device:MediaRenderer:1`，其中最后的数字1就是版本号。

此外，MediaRenderer的版本和所包含服务的版本，有一定的对应关系。比如MediaServer:4中的ScheduledRecording:2。因为ScheduledRecording是在MediaServer:2中引入的，因此它的版本号就不可能和MediaServer的版本号一致。MediaRenderer也是一样的情况。

一个服务可以提供若干功能。这些功能主要包括三方面：

1.状态变量（State Variables）。状态变量可以进行查询操作。

2.动作（Action）。get类的Action可以实现和查询状态变量类似的效果，但比后者要复杂一些。

3.事件（Eveting）。事件是设备（Device）主动推送给控制点（Control Point）的消息，需要后者订阅（SUBSCRIBE）或退订（UNSUBSCRIBE）。

### 初始化

src/main.c: main

src/upnp_device.c: upnp_device_init

src/upnp_device.c: initialize_device

upnp/src/api/upnpapi.c: UpnpInit

### 动作（Action）处理

1.数据结构

相关数据结构按从大到小的顺序，依次为：

服务->动作->参数->值类型->基本数据类型

这里从最小的基本数据类型说起。由于MediaRenderer的三个服务在这里的细节都是类似的，因此下面仅以RenderingControl为例。

1)基本数据类型

src/upnp.h: param_datatype定义了可用的基本数据类型，比如STRING、BOOLEAN、I2、I4、UI2、UI4等。后四种都是整数类型，I表示整数，U表示无符号，2表示2个字节的宽度。

2)值类型

src/upnp.h: var_meta定义了值类型的数据结构。该类型的实例是src/upnp_control.c: control_var_meta。var_meta的sendevents成员的含义是，如果该值发生改变时，发送消息则设置为SENDEVENT_YES（默认值），否则设为SENDEVENT_NO。

3)参数

src/upnp.h: argument定义了参数的数据结构。典型示例如下：

`{ "InstanceID", PARAM_DIR_IN, CONTROL_VAR_AAT_INSTANCE_ID }`

3)动作

一个动作包含若干参数，因此动作的数据结构是一个argument数组。以SetVolume动作为例，它的参数结构的实例为src/upnp_control.c: arguments_set_vol。

4)服务

一个服务包含若干动作，因此服务的数据结构是一个argument的二维数组。在这里是src/upnp_control.c: argument_list。

服务不仅包含动作，还包含了其他一些东西，这些都被统一组织到src/upnp.h: service结构中。该结构的实例是src/upnp_control.c: control_service_。

### 功能发布

功能发布用于向外界宣布本服务所支持的功能。

gmediarender功能发布的内容是动态生成的，其函数为：src/upnp.c: gen_scpd

### 事件处理

src/upnp_device.c: event_handler

### 返回值处理

src/upnp_device.h: upnp_add_response

调用这个函数或者它的派生函数，生成返回值的xml。

## gmediaserver

除了gmediarender项目之外，GNU还有个名叫gmediaserver的项目，也是使用libupnp库，结构和gmediarender十分相似，它的官网是：

http://www.nongnu.org/gmediaserver/

## upnp-inspector

upnp-inspector是一个局域网内的UPNP协议的嗅探分析器。可充当DMC，推送多媒体数据到相关DLNA设备。安装方法如下：

`sudo apt-get install upnp-inspector`


