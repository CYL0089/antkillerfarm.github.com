---
layout: post
title:  浮点运算和代码优化, 音频常识
category: technology 
---

# 浮点运算和代码优化

## 1.浮点运算问题

浮点运算在工业中应用非常广泛，但嵌入式CPU通常没有对浮点运算提供直接的硬件支持。而采用标准库提供的软件计算方案，性能又很差。这时就需要使用浮点运算协处理器加速浮点运算。（486之前的PC，CPU和浮点运算协处理器FPU也是分开的，例如i486DX是有FPU的型号，而i486SX则是没有FPU的型号。）

硬件的支持离不开软件的使用。如果在添加了FPU的硬件上，使用浮点计算的软件方案的话，FPU也是不起作用的。因此必须用FPU驱动库函数替换标准库提供的软件方案的相应函数。

最直观的做法是将所有用到浮点计算的地方都替换成FPU函数。例如如下代码：

{% highlight c %}
float a,b,c;
a = b + c;
{% endhighlight %}

假设FPU加法函数的原型为：

`float Add(float a, float b);`

如果我们要使用FPU硬件加速的话，只需要将上述代码改为：

{% highlight c %}
float a,b,c;
a = Add(b,c);
{% endhighlight %}

就可以了。

上面的这种方法显然是直观而正确的，但是却不方便。需要将源代码中，所有涉及到浮点运算的地方都做相应的修改，而且以函数的方式取代C语言中的运算符，本身书写起来也很麻烦。

我们可以这样思考一下，C语言是如何将运算符转换成机器指令的呢？首先编译阶段肯定要做类型判断，整数加法和浮点数加法的指令显然不会相同。而链接阶段，只有符号表的概念，类型也好、运算符也好，都灰飞烟灭了。

因此，我们只要看一看浮点加法的汇编指令，就可以找到相关的符号表了。经查浮点加法对应的符号是__adddf3（gcc下）。因此它的原型就是：

`float64 __adddf3(float64 x, float64 y)`

将FPU函数写成这个样子，然后在链接阶段替换标准库函数就可以了。具体操作如下：

1.使用nm命令查看libgcc.a中的符号表，可以查到__adddf3在_addsub_df.o中。

2.使用ar命令的d选项从libgcc.a中去掉_addsub_df.o。

3.在链接时使用FPU函数库

## 2.立即数计算量的问题

请看以下代码：

{% highlight c %}
float64 a, b,c;
a = 2*PI * (b - c) / 365.25;
{% endhighlight %}

机器执行这段代码会进行几次运算呢？

答案是3次。虽然有4个运算符，但2*PI是在编译阶段运算的。（这可以通过查看生成的汇编代码来验证。）基于同样的理由，我们还可以改进这段代码：

`a = 2*PI / 365.25 * (b - c);`

这样只需要2次运算了。

需要说明的是括号如果不改变运算的顺序的话，是不会改变计算次数的。因此

`a = (2*PI / 365.25) * (b - c);`

和

`a = 2*PI / 365.25 * (b - c);`

是等效的，都只需要2次运算。

## 3.冗余代码的问题

假设我们定义了a函数，但是在其他地方并未使用该函数，我们是否可以认为a函数的代码不会出现在最终的可执行文件中呢？

这个问题至少在gcc没有设置任何参数时，是否定的。不管a函数使用与否，它的代码都会包含在最终的可执行文件中。

对于PC来说，这不是个太大的问题，但对于嵌入式设备来说，任何空间的浪费都是不可接受的。

写到这里，有人会说，使用gcc的-o2选项优化代码，不就可以了吗？遗憾的是，这是不行的。

-o2有什么作用呢？还是上面的例子：

{% highlight c %}
void main()
{
  float64 a, b,c;
  a = 2*PI * (b - c) / 365.25;
}
{% endhighlight %}

如果是-o2选项的话，机器会进行几次运算呢？

答案是0次。这种不涉及到输出结果的计算，直接被忽略掉了。

回到第一个问题。如何做才能在最终的可执行文件中不包含未使用的函数呢？步骤如下：

1. gcc添加-ffunction-sections选项。我们通常的做法是一个.c文件编译生成一个.o文件。而这个.c文件中的函数代码都会包含在.o文件的.text段（section）中。而-ffunction-sections选项会将每个函数放在单独的段中，例如a函数，会被放到.text.a段中。

2. ld添加--gc-sections选项。这个选项的作用是不链接未使用的段。

从上面的步骤可以看出，链接的最小单位既不是.o文件，也不是单个函数，而是段。

使用以上方法生成的程序，理论上没什么问题，但实际中，还是有不方便之处：为每一个函数生成一个段，可以想象可执行文件中会有多少段，而在某些平台上，代码在段之间的跳转是要比段内跳转消耗资源的。

我们可以在链接脚本中合并这些段，以下是一个简单的实例：

{% highlight bash %}
.text :
{
  . = ALIGN(4);
  text_start = .;
  *(.text.*)
  . = ALIGN(4);
  text_end = .;
}
{% endhighlight %}

# 音频常识

## IIS

亦称I2S。Inter—IC Sound总线是飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准，该总线专责于音频设备之间的数据传输，广泛应用于各种多媒体系统。

## 各种编解码算法比较

http://www.rosoo.net/a/201012/10600.html

这个帖子比较了ITU提出的G系列的各种语音编解码方案。

![](/images/article/audio.png)

上图是各种音频编解码框架的比较图。

其中narrowband是指频率在4kHz以下的声音信号，一般情况下，人的说话声就位于这个频率范围内，因此又被称为“语音”。

allband是指频率在24kHz以下的声音信号。这也是人耳所能听到的频率范围。这个范围内的声音统称“音频”。

介于两者之间的，被称为wideband。

## 声道

声道一般表示为X.Y的形式，其中X为高音音箱的个数，Y为低音音箱的个数。比如常见的2.1声道，就是左音箱、右音箱+低音音箱（俗称低音炮）。

一般来说，Y的值为0或1。而X的值，有以下几种：

1.X=1。单声道

2.X=2。左、右。

3.X=4。前左、前右，后左、后右。

4.X=5。前左、前右，后左、后右、中置。

5.X=7。前左、前右，后左、后右、中置、中左、中右。

## 数字功放

![](/images/article/tas5731_2_1.png)

上图是TI TAS5731M的2.1声道应用图。

其中的SE，表示单端连接模式（Single-End），和桥接式负载 BTL（Bridge-Tied-Load）相对应。后者在同等供电电压和负载的情况下，可以提供4倍于SE的输出功率，并具有良好的低频响应，常用于连接低音音箱。

![](/images/article/digital_audio.png)

这是TI TAS5731M数字音频的处理流程，其中上两路是高音声道，最下面一路是低音声道。

## ALSA System on Chip (ASoC) layer

这是专为嵌入式设备设计的ALSA框架。官网是：

http://www.alsa-project.org/main/index.php/ASoC

![](/images/article/dm81xx_asoc_architecture.png)

上图是TI某平台的ASOC架构图。其中的ASoC layer可分为三个不同的部分：

1.Codec driver。这部分是平台无关的，包括了音频接口配置、音频控制、电源管理和其他IO功能。所谓平台是若干使用相同SOC的机型的集合。

2.Platform driver。这部分主要是平台相关的音频接口驱动和相关的DMA驱动。

3.Machine driver。这部分用于前两部分之间的协调，起到粘合剂的作用。它通常是与具体使用的机器相关的。

以三星设备为例，Platform driver和Machine driver在sound/soc/samsung下，该文件夹的Makefile节选如下：

{% highlight bash %}
# S3c24XX Platform Support
snd-soc-s3c24xx-i2s-objs := s3c24xx-i2s.o
snd-soc-s3c2412-i2s-objs := s3c2412-i2s.o

obj-$(CONFIG_SND_S3C24XX_I2S) += snd-soc-s3c24xx-i2s.o
obj-$(CONFIG_SND_S3C2412_SOC_I2S) += snd-soc-s3c2412-i2s.o

# S3C24XX Machine Support
snd-soc-s3c24xx-uda134x-objs := s3c24xx_uda134x.o
snd-soc-s3c24xx-simtec-objs := s3c24xx_simtec.o

obj-$(CONFIG_SND_SOC_SAMSUNG_S3C24XX_UDA134X) += snd-soc-s3c24xx-uda134x.o
obj-$(CONFIG_SND_SOC_SAMSUNG_SIMTEC) += snd-soc-s3c24xx-simtec.o
{% endhighlight %}

Codec driver在sound/soc/codecs下，该文件夹的Makefile节选如下：

{% highlight bash %}
snd-soc-uda134x-objs := uda134x.o
snd-soc-uda1380-objs := uda1380.o

obj-$(CONFIG_SND_SOC_UDA134X)	+= snd-soc-uda134x.o
obj-$(CONFIG_SND_SOC_UDA1380)	+= snd-soc-uda1380.o
{% endhighlight %}

## ASoC术语表

DAI: Digital Audio Interface

DAPM：Dynamic Audio Power Management

## ALSA从2.6.X到3.X的变化细节

网上的文章有不少都是针对2.6.X的老内核的，现将3.X引入的变化，罗列如下：（自己摘录，仅供备忘，非官方内容）

1.snd_card_create改为snd_card_new。

## 从Gstreamer到ALSA

Gstreamer通过alsasink和alsasrc这两个插件访问ALSA API。这两个插件在gst-plugins-base代码的ext/alsa文件夹下。

gst-plugins-base的git地址是：

git://anongit.freedesktop.org/gstreamer/gst-plugins-base

ALSA API的代码在alsa-lib中，它的git地址是：

git://git.alsa-project.org/alsa-lib.git

ALSA API会调用ALSA driver，而driver的代码肯定在linux内核中。

alsa-lib中的很多常用功能，被做成了动态链接库，例如：alsa-lib/libasound_module_pcm_pulse.so，这些链接库的代码在alsa-plugins中。alsa-plugins的git地址是：

git://git.alsa-project.org/alsa-plugins.git

1.open操作

gst-plugins-base/ext/alsa/gstalsasink.c: gst_alsasink_open

这一步之后，进入alsa-lib作用域。

alsa-lib/src/pcm/pcm.c: snd_pcm_open

alsa-lib/src/pcm/pcm.c: snd_pcm_open_noupdate

alsa-lib/src/pcm/pcm.c: snd_pcm_open_conf

alsa-lib中pcm有很多插件，提供诸如硬件、复制、线性变换等操作。详见alsa-lib/include/pcm_plugin.h。

alsa-lib/src/pcm/pcm_hw.c: _snd_pcm_hw_open

alsa-lib/src/pcm/pcm_hw.c: snd_pcm_hw_open

alsa-lib/include/local.h: snd_open_device

这个函数调用open系统调用，进入内核空间。在内核空间中根据driver模型的不同，进入

linux-kernel/sound/core/pcm_native.c: snd_pcm_open（ALSA）或 linux-kernel/sound/soc/soc-pcm.c: soc_pcm_open（ASOC）

2.write操作

gst-plugins-base/ext/alsa/gstalsasink.c: gst_alsasink_write

这一步之后，进入alsa-lib作用域。

alsa-lib/src/pcm/pcm.c: snd_pcm_writei

alsa-lib有两种写操作：snd_pcm_writei和snd_pcm_writen。snd_pcm_writei表示写入交织的PCM数据，而snd_pcm_writen表示写入非交织的PCM数据。

alsa-lib/src/pcm/pcm_local.h: _snd_pcm_writei

alsa-lib/src/pcm/pcm_hw.c: snd_pcm_hw_writei

这个函数调用ioctl系统调用，参数为SNDRV_PCM_IOCTL_WRITEI_FRAMES，pcm数据的buffer，放在snd_xferi结构中，传入内核空间。

linux-kernel/sound/core/pcm_native.c: snd_pcm_playback_ioctl1

linux-kernel/sound/core/pcm_lib.c: snd_pcm_lib_write

linux-kernel/sound/core/pcm_lib.c: snd_pcm_lib_write_transfer

这里会有两个分支，以下仅讨论DMA方式的处理。pcm数据放在snd_pcm_substream.runtime->dma_area指向的缓冲区。open的时候，使用mmap做好snd_pcm_substream.runtime->dma_area和snd_pcm_substream.runtime->dma_addr之间的映射。底层驱动只须操作dma_addr即可。

