---
layout: post
title:  浮点运算和代码优化, 并行计算, Optimizer软件
category: AI 
---

# 浮点运算和代码优化

## 1.浮点运算问题

浮点运算在工业中应用非常广泛，但嵌入式CPU通常没有对浮点运算提供直接的硬件支持。而采用标准库提供的软件计算方案，性能又很差。这时就需要使用浮点运算协处理器加速浮点运算。（486之前的PC，CPU和浮点运算协处理器FPU也是分开的，例如i486DX是有FPU的型号，而i486SX则是没有FPU的型号。）

硬件的支持离不开软件的使用。如果在添加了FPU的硬件上，使用浮点计算的软件方案的话，FPU也是不起作用的。因此必须用FPU驱动库函数替换标准库提供的软件方案的相应函数。

最直观的做法是将所有用到浮点计算的地方都替换成FPU函数。例如如下代码：

{% highlight c %}
float a,b,c;
a = b + c;
{% endhighlight %}

假设FPU加法函数的原型为：

`float Add(float a, float b);`

如果我们要使用FPU硬件加速的话，只需要将上述代码改为：

{% highlight c %}
float a,b,c;
a = Add(b,c);
{% endhighlight %}

就可以了。

上面的这种方法显然是直观而正确的，但是却不方便。需要将源代码中，所有涉及到浮点运算的地方都做相应的修改，而且以函数的方式取代C语言中的运算符，本身书写起来也很麻烦。

我们可以这样思考一下，C语言是如何将运算符转换成机器指令的呢？首先编译阶段肯定要做类型判断，整数加法和浮点数加法的指令显然不会相同。而链接阶段，只有符号表的概念，类型也好、运算符也好，都灰飞烟灭了。

因此，我们只要看一看浮点加法的汇编指令，就可以找到相关的符号表了。经查浮点加法对应的符号是__adddf3（gcc下）。因此它的原型就是：

`float64 __adddf3(float64 x, float64 y)`

将FPU函数写成这个样子，然后在链接阶段替换标准库函数就可以了。具体操作如下：

1.使用nm命令查看libgcc.a中的符号表，可以查到__adddf3在_addsub_df.o中。

2.使用ar命令的d选项从libgcc.a中去掉_addsub_df.o。

3.在链接时使用FPU函数库

## 2.立即数计算量的问题

请看以下代码：

{% highlight c %}
float64 a, b,c;
a = 2*PI * (b - c) / 365.25;
{% endhighlight %}

机器执行这段代码会进行几次运算呢？

答案是3次。虽然有4个运算符，但2*PI是在编译阶段运算的。（这可以通过查看生成的汇编代码来验证。）基于同样的理由，我们还可以改进这段代码：

`a = 2*PI / 365.25 * (b - c);`

这样只需要2次运算了。

需要说明的是括号如果不改变运算的顺序的话，是不会改变计算次数的。因此

`a = (2*PI / 365.25) * (b - c);`

和

`a = 2*PI / 365.25 * (b - c);`

是等效的，都只需要2次运算。

## 3.冗余代码的问题

假设我们定义了a函数，但是在其他地方并未使用该函数，我们是否可以认为a函数的代码不会出现在最终的可执行文件中呢？

这个问题至少在gcc没有设置任何参数时，是否定的。不管a函数使用与否，它的代码都会包含在最终的可执行文件中。

对于PC来说，这不是个太大的问题，但对于嵌入式设备来说，任何空间的浪费都是不可接受的。

写到这里，有人会说，使用gcc的-o2选项优化代码，不就可以了吗？遗憾的是，这是不行的。

-o2有什么作用呢？还是上面的例子：

{% highlight c %}
void main()
{
  float64 a, b,c;
  a = 2*PI * (b - c) / 365.25;
}
{% endhighlight %}

如果是-o2选项的话，机器会进行几次运算呢？

答案是0次。这种不涉及到输出结果的计算，直接被忽略掉了。

回到第一个问题。如何做才能在最终的可执行文件中不包含未使用的函数呢？步骤如下：

1. gcc添加-ffunction-sections选项。我们通常的做法是一个.c文件编译生成一个.o文件。而这个.c文件中的函数代码都会包含在.o文件的.text段（section）中。而-ffunction-sections选项会将每个函数放在单独的段中，例如a函数，会被放到.text.a段中。

2. ld添加--gc-sections选项。这个选项的作用是不链接未使用的段。

从上面的步骤可以看出，链接的最小单位既不是.o文件，也不是单个函数，而是段。

使用以上方法生成的程序，理论上没什么问题，但实际中，还是有不方便之处：为每一个函数生成一个段，可以想象可执行文件中会有多少段，而在某些平台上，代码在段之间的跳转是要比段内跳转消耗资源的。

我们可以在链接脚本中合并这些段，以下是一个简单的实例：

{% highlight bash %}
.text :
{
  . = ALIGN(4);
  text_start = .;
  *(.text.*)
  . = ALIGN(4);
  text_end = .;
}
{% endhighlight %}

## IEEE 754

|  | Sign | Exponent | Fraction |
|:--:|:--:|:--:|:--:|
| FP16 | 1 | 5 | 10 |
| FP32 | 1 | 8 | 23 |
| FP64 | 1 | 11 | 52 |

参考：

https://en.wikipedia.org/wiki/IEEE_754

https://mp.weixin.qq.com/s/9YKlVtumOmSGa-mE32ZUBA

x86-64体系下一个奇怪问题的定位

# 并行计算

## 概述

并行计算的必要性：

美国Sandia国家实验室一项模拟测试证明：由于存储机制和内存带宽的限制，16核、32核甚至64核处理器对于超级计算机来说，不仅不能带来性能提升，甚至可能导致效率的大幅度下降。必须研究并行计算的算法，才能有效克服这些缺陷。

最早的并行计算项目是斯坦福大学的BrookGPU：

http://graphics.stanford.edu/projects/brookgpu/

科学家们很早就意识到GPU进行通用数值计算的可行性。然而GPU从创建之初，就主要针对图形渲染，早期的通用计算需要通过很复杂的处理，才能安排到GPU的pipeline中进行运算。BrookGPU的作用就是给通用数值计算提供一个相对简单的接口。

随着GPU厂商逐渐意识到通用数值计算的重要性，并陆续提出了一些新框架。BrookGPU项目也就过时了。

常见并行计算框架

| 名称 | 优点 | 缺点 |
|:--:|:--:|:--:|
| CUDA | 生态系统良好，发展成熟。 | 只能NV的卡。 |
| OpenCL | 跨平台，很容易异构计算。 | 大家都把它当作干儿子，没人认真写它的驱动。 |
| C++ AMP | 基于Direct compute，易于使用。 | Windows Only。 |
| OpenMP | 移植改动少 | CPU多线程而已，和GPU无关。 |
| Metal | for iOS | - |

其他的并行计算框架还有：OpenACC、AMD stream、PGI。

NVIDIA相关产品线：

Tesla产品专为数据中心与工作站计算应用而设计。

Quadro产品专为专业图形与工程应用而设计。

GeForce产品专为互动游戏与消费类应用而设计。

## OpenCL vs CUDA

![](/images/article/opencl_cuda.jpg)

## 教程

http://blog.csdn.net/augusdi/article/details/12833235

这是一篇转帖的CUDA教程，原帖比较分散，不好看。

# Optimizer软件

在前ML时代，工业界已经有不少Optimizer软件用于求解凸优化问题，这些软件从原理上基本都属于传统统计学的范畴。

比较知名的Optimizer软件有：CPlex, Gurobi, Mosek, cvx, LINGO

参考：

https://mp.weixin.qq.com/s/kdfGUzY6KnI3tpcDg0GX6w

运筹优化问题求解工具Lingo

# 目标跟踪

## 概述

目标跟踪（object tracking）就是在连续的视频序列中，建立所要跟踪物体的位置关系，得到物体完整的运动轨迹。

目标跟踪分为单目标跟踪和多目标跟踪。本文如无特别指出，均指单目标跟踪。

通常的做法是：

1.在第1帧给一个bbox框住需要跟踪的物体。

2.在不借助重检测（re-detection）的情况下，尽可能长时间的跟住物体。

3.不能使用依赖外部特征的姿态估计（pose estimation）。

当然这是针对目标跟踪算法的要求，至于实际产品中，对象的重检测以及依赖外部特征的姿态估计都是必不可少的。

比如，自动驾驶领域的车辆跟踪，一般都会针对车辆的运动特点建立模型，以辅助目标跟踪。

## TB50 & TB100

这个领域最著名的数据集是吴毅提出的TB50 & TB100，50和100分别代表视频数量。有的论文也把它们称作OTB-2013和OTB-2015。

>吴毅，中国科学院自动化研究所博士（2009年）。南京审计大学副教授。

官网：

http://cvlab.hanyang.ac.kr/tracker_benchmark/

论文：

《Online object tracking: A benchmark》

《Object tracking benchmark》

上面的论文在TB数据集上比较了包括2012年及之前的29个顶尖的tracker，基本解决了统一标准的问题，因此也成为了目标跟踪领域的权威数据集。

《Object tracking: A survey》

这篇论文总结了2006年以前的目标跟踪算法。

## VOT

VOT竞赛数据集是另一个常用数据集。官网：

http://votchallenge.net/challenges.html

OTB包括25%的灰度序列，但VOT都是彩色序列，这也是造成很多颜色特征算法性能差异的原因。

## 目标跟踪的难点

![](/images/article/tracker_hard.png)

![](/images/article/tracker_hard_2.png)

## 目标跟踪算法的分类

![](/images/img2/object_tracking.png)

上图是目标跟踪算法的分类，下表是具体分类和代表算法。

![](/images/img2/object_tracking_2.png)

**点跟踪**：在连续帧中检测到的目标被表达为点。这种方法需要引入其它方法来进行目标检测。

**核跟踪**：关联与目标的形状和外观表达。核函数可以是关联与一个直方图的矩形或椭圆模板。目标通过在连续帧中计算核的运动来跟踪。运动可以是参数形式的平移、旋转或仿射等。

**轮廓跟踪**：由在每帧中估计目标区域进行跟踪。轮廓跟踪方法用到的信息可以是外观密度和形状模型。给定目标模型，轮廓由形状匹配或轮廓推导得到。这些方法都可以视作时域上的目标分割。

按照是否依赖先验知识可分为两类：

1.不依赖于先验知识，直接从图像序列中检测到运动目标，并进行目标识别，最终跟踪感兴趣的运动目标；

2.依赖于目标的先验知识，首先为运动目标建模，然后在图像序列中实时找到相匹配的运动目标。

按照摄像机是否固定，可分为：

1.静态背景。

2.运动场。摄像机的运动形式可以分为两种：a)摄像机的支架固定，但摄像机可以偏转、俯仰以及缩放; b)将摄像机装在某个移动的载体上。

经典的目标跟踪算法主要有：meanshift、camshift、Kalman filter、particle filter、Optical flow、TLD、KCF、Struck等。

参考：

https://blog.csdn.net/app_12062011/article/details/48436959

目标跟踪算法的分类（一）

https://blog.csdn.net/app_12062011/article/details/51760256

目标跟踪算法的分类（二）

https://blog.csdn.net/app_12062011/article/details/52277537

目标跟踪算法的分类（三）

## 多目标追踪

Multiple Object Tracking

https://zhuanlan.zhihu.com/p/34730368

多目标追踪

https://zhuanlan.zhihu.com/p/36462982

多目标追踪算法：条件随机场算法

## 参考

https://www.zhihu.com/question/26493945

计算机视觉中，目前有哪些经典的目标跟踪算法？

https://mp.weixin.qq.com/s/Wz-loMz1oOlxtm10gazQRg

目标检测（Object Detection）和目标跟踪（Object Tracking）的区别
