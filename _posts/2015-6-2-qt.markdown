---
layout: post
title:  Qt, GStreamer, Python
category: technology 
---

# Qt主循环

这篇文章有个大概的比较和说明：

http://blog.chinaunix.net/uid-20754930-id-1877623.html

以下是我针对Qt5代码（2015.4）的一个研究。

QApplication::exec

QGuiApplication::exec

QCoreApplication::exec

QEventLoop::exec

QEventLoop::processEvents

QEventDispatcher::processEvents

再以下就和具体的平台相关了。

Windows平台：

QEventDispatcherWin32::processEvents

它的实现主要是GetMessage+WaitForMultipleObjects，如上文中对MiniGUI的主循环所述。

Unix平台：

QEventDispatcherUNIX::processEvents

QEventDispatcherUNIXPrivate::doSelect

这个函数主要使用select系统调用来监听事件源。

Android平台：

QAndroidEventDispatcher::processEvents

QUnixEventDispatcherQPA::processEvents

QEventDispatcherUNIX::processEvents

以下和Unix平台相同。

# Qt多线程中connect的使用

近日在研究OpenGL多线程处理时，偶然看到了如下代码：

http://download.csdn.net/detail/zhoukuanbin/7669187

没有CSDN账号的读者，也可以在这里下载：

https://github.com/antkillerfarm/antkillerfarm_crazy/tree/master/Qt/MyGlTest

粗看代码，发现并无特殊的OpenGL处理，理论上应该无法达到一个线程处理渲染，另一个线程处理贴图的目标。但实际编译运行代码，又确实可用。因此这里面一定有什么原因。

{% highlight cpp %}
void ThreadGl::run()
{
    connect(this, SIGNAL(SigCopy()), this, SLOT(Copy()));
    printf("ID 0:%x\n", currentThreadId());
    while(1)
    {
        if(!m_bEndFlag)
        {
            break;
        }

        usleep(16000);
        emit SigCopy();
    }

    qDebug("Copy End\n");
}

void ThreadGl::Copy()
{
    m_glWidgets -> OnTimeOut(m_pImage, m_Formal, m_pthId);
}
{% endhighlight %}

这段代码引起了我的注意。粗一看，connect函数连接的SIGNAL和SLOT都属于同一个对象。而connect函数的第5个参数（这是个有默认值的可省略参数）的默认值为Qt::AutoConnection。

这是Qt官方对Qt::AutoConnection的解释：

* If the receiver lives in the thread that emits the signal, Qt::DirectConnection is used. Otherwise, Qt::QueuedConnection is used. The connection type is determined when the signal is emitted.

按照字面上的意思，既然SIGNAL和SLOT都属于同一个对象，那么这里的Qt::AutoConnection就等同于Qt::DirectConnection。而Qt::DirectConnection与直接调用SLOT函数是一个效果。

于是这里将`emit SigCopy();`替换为`Copy();`，结果程序运行出错。

再试一下，将connect函数的第5个参数设为Qt::DirectConnection，同样有问题。

而如果将之设为Qt::QueuedConnection的话，程序运行一切正常。

综上，Qt在这里的处理，显然认为SIGNAL和SLOT属于**不同的**线程。

那么判断的依据是什么呢？

这里有必要对`emit SigCopy();`中`emit`背后的戏法做一个剖析。

众所周知，emit并非C++关键字，而属于Qt扩展的一部分。Qt为了处理这些扩展，引入了moc工具作为预处理工具。

而moc处理之后，`emit SigCopy();`就变成了`QMetaObject::activate`

`QMetaObject::activate`中使用以下代码，判定信号接收者的线程是否和信号发送者的一致。

{% highlight cpp %}
const bool receiverInSameThread = currentThreadId == receiver->d_func()->threadData->threadId;
{% endhighlight %}

于是问题转化为`receiver->d_func()->threadData`是怎么来的呢？

答案在`QObject::QObject`中：

{% highlight cpp %}
d->threadData = (parent && !parent->thread()) ? parent->d_func()->threadData : QThreadData::current();
{% endhighlight %}

从这里可以看出所谓信号接收者的线程，实际上是接收者对象创建时所处的线程。

回到原来的问题。ThreadGl虽然是Qt的线程对象，但它本身却是在主线程中创建的，所以以它为接收者，实际上就是以主线程为接收者。

显然这个例子代码并没有真正实现OpenGL多线程处理，所有的OpenGL操作实际上都是在主线程完成的。

# GStreamer

## 1.概况

当前GStreamer主要有两个大的版本分支：

1)0.10.x系列。这个版本系列的历史较久，相关资源比较丰富。但目前官方已经不再发展和支持该版本。该系列有中文版的用户手册。

2)1.x系列。2012年以来发布的版本系列，也是官方推荐的版本系列。只有英文的用户手册，但手册的内容与0.10.x相差不大，尽管API已经不再兼容旧版本。以下的描述以1.x系列为准。1.x系列被设计为可以和0.10.x系列在系统中共存，因此在同一台电脑上，同时安装0.10.x系列和1.x系列是完全没有冲突的。

GStreamer本质上只是一个多媒体应用框架，具体的多媒体播放功能由插件来完成。

http://gstreamer.freedesktop.org/documentation/plugins.html

这个网页就是gstreamer的插件列表。表中列出的插件，分属4个不同的插件集：

* gst-plugins-base。这类插件格式规范，维护的也很好。

* gst-plugins-good。这类插件有高质量的代码（但格式未必规范），而且许可证也符合要求（LGPL或与LGPL兼容的许可证）。

* gst-plugins-ugly。这类插件有高质量的代码，但许可证方面有问题。

* gst-plugins-bad。这类插件尚不成熟，需要更多文档、测试和应用。

插件安装方法，以gst-plugins-base为例。

`sudo apt-get install gstreamer1.0-plugins-base`

## 2.开发环境搭建

`sudo apt-get install libgstreamer1.0-dev`(1.x系列)

`sudo apt-get install libgstreamer0.10-dev`(0.10.x系列)

helloworld程序在

https://github.com/antkillerfarm/antkillerfarm_crazy/tree/master/gstreamer/helloworld

这里的代码尽管是针对1.x系列的，但实际上对于0.10.x系列也同样有效，你需要做的只是将Makefile中的

{% highlight bash %}
CFLAGS = `pkg-config --cflags gstreamer-1.0`
LDFLAGS = `pkg-config --libs gstreamer-1.0`
{% endhighlight %}

改为

{% highlight bash %}
CFLAGS = `pkg-config --cflags gstreamer-0.10`
LDFLAGS = `pkg-config --libs gstreamer-0.10`
{% endhighlight %}

这个例子同时也是如何使用pkg-config来管理同一软件的不同版本的范例。GTK+ 2.x和GTK+ 3.x的共存，也是采用了同样的方法。

## 3.相关工具软件

GStreamer提供了一个工具软件集——gstreamer-tools。其安装方法如下：

`sudo apt-get install gstreamer-tools gstreamer1.0-tools`

具体的工具列表参见

http://blog.csdn.net/jackyy313/article/details/6275673

注意1.x系列的工具名和0.10.x系列的略有不同，例如`gst-launch`在1.x系列中叫做`gst-launch-1.0`。

这里对其中的一些工具，稍作阐述。

gst-launch：这个工具可以用于创建并运行GStreamer管道。下面是一个播放mp3文件的示例:

`gst-launch filesrc location=1.mp3 ! mad ! audioconvert ! autoaudiosink`

需要注意的是上面的命令中，`!`两边都要留空格，不然命令会执行错误。

## 4.playbin插件

该插件使用了GStreamer的自动加载（Auto plugging）机制，可以自动根据媒体类型，选择不同的管道播放，相当于是个万能播放插件。对于GStreamer应用开发人员来说，是个相当好用的东西。

# Python

## PyPI

PyPI是一个Python语言的软件库管理软件，它的官网是：

https://pypi.python.org/pypi

用户可以在这里查找自己需要的Python包。

Ubuntu下的安装方法是：

`sudo apt-get install python-pip`

使用方法是：

`sudo pip install <package name>`

## PyGObject

谈起Python调用GTK+的话题，在GTK+ 2的时代可以使用PyGTK库。它的官网是：

http://www.pygtk.org/

但由于PyGTK库本质上来说，使用了和一般的Python调用C库一样的方法，因此每导入一个库，都需要编写大量的接口文件。GNOME工程有那么多项目，采用这种办法显然是不太可行的。

于是，GNOME工程发起了GObject Introspection项目。众所周知，GNOME工程诸多项目的基石是GObject。这是一个很成功的类型系统，使用该系统可以获得远比普通C库更强的支持。GObject Introspection项目的目标就是创建一个用于跨语言绑定的中间层。这个项目的官网是：

https://wiki.gnome.org/Projects/GObjectIntrospection

随着GObject Introspection项目的进展，越来越多的语言绑定开始使用这套系统，python也不例外。PyGObject项目就是这种方法的成果，目前它已经取代了PyGTK库，成为GTK+ 3时代Python调用GTK+的官方方案。它的官网是：

https://wiki.gnome.org/Projects/PyGObject

相关的API参考文档可参见：

http://lazka.github.io/pgi-docs/

指南文档可参见：

http://python-gtk-3-tutorial.readthedocs.org/en/latest/

安装方法：

Ubuntu下，可以执行：

`sudo apt-get install python-gi python3-gi`

Windows下，有个PyGObject for Windows项目，该项目的官网是：

http://sourceforge.net/projects/pygobjectwin32/files/

PyGObject的helloworld程序可参见：

https://github.com/antkillerfarm/antkillerfarm_crazy/blob/master/python/pygtk-helloworld.py

## Sqlite

Ubuntu下的安装方法是：

`sudo apt-get install sqlite`

Python自带了pysqlite包，用于调用sqlite。

pysqlite的helloworld程序可参见：

https://github.com/antkillerfarm/antkillerfarm_crazy/blob/master/python/pysqlite-helloworld.py

可以使用sqlite_bro软件包，查看sqlite数据库。安装方法：

`sudo pip install sqlite_bro`

## python调用GTK函数的一般规则

众所周知，GTK库是用C语言编写的，其相关的文档提供的也是C函数的接口，python接口的文档相对较少，获得也不太容易。因此有必要掌握一下这方面基本的命名规则。（这里只讲方法，对深层次的调用原理不做探究。）

1）类初始化函数

C:`GtkWidget * gtk_button_new (void);`

python:`button = Gtk.Button()`

这里除了把C函数式的写法，替换成python的类的写法之外，并无其他差异。

2）普通类成员函数

C:`void gtk_container_add (GtkContainer *container, GtkWidget *widget);`

python:`button.add(image)`

可以看出，C函数的第一个表示self类指针的参数被省略掉了。

3）回调函数

这里以按钮的click事件回调为例：

C:`void user_function (GtkButton *button, gpointer user_data)`

python:

`button.connect("clicked", self.playToggled)`

`def playToggled(self, w):`

这里的情况要复杂的多。首先在事件回调注册的时候，由于我们并没有给user_data赋值，因此照理说playToggled函数，只有button这一个参数。但实际传递给playToggled函数的有两个参数，self是一个用于占位的参数，w对应button，没有东西对应user_data。

4）用于输出的参数

C:`void gst_message_parse_error (GstMessage *message, GError **gerror, gchar **debug);`

python:`err, debug = message.parse_error()`

这个例子中的gerror和debug都是用于输出的参数。如果只想得到其一，还可用以下方法:

`debug = message.parse_error()[2]`

5）枚举类型

C:

{% highlight c %}
enum GstSeekFlags
{
  GST_SEEK_FLAG_FLUSH,
  ...
}
{% endhighlight %}

python:`Gst.SeekFlags.FLUSH`

6）宏常量

C:`#define GST_CLOCK_TIME_NONE ((GstClockTime) -1)`

python:`Gst.CLOCK_TIME_NONE`

7）类型转换

大多数情况下，类型转换自动完成，并无什么问题。这里只讨论特殊的情况。

C:

{% highlight c %}
gst_element_seek (pipeline, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
                         GST_SEEK_TYPE_SET, time_nanoseconds,
                         GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
{% endhighlight %}

python:

{% highlight python %}
self.player.seek(1.0, Gst.Format.TIME, Gst.SeekFlags.FLUSH, Gst.SeekType.SET,\
                 time_nanoseconds, Gst.SeekType.NONE, Gst.CLOCK_TIME_NONE)
{% endhighlight %}

这里首先按照一般的方法，将C代码转化成python代码。但是运行之后，产生如下错误：

`OverflowError: long too big to convert`

究其原因，gst_element_seek的最后一个参数是uint64类型的。但python原生并不支持该类型，而是将之转换成int类型（实际上是int64类型），这样的话，GST_CLOCK_TIME_NONE的值显然超出了int64所能表示的范围。

解决的办法是使用ctypes库，将

`Gst.CLOCK_TIME_NONE`

改为

`c_long(Gst.CLOCK_TIME_NONE).value`

# GStreamer的Python开发教程

## Step 0——helloworld

代码参见：

https://github.com/antkillerfarm/antkillerfarm_crazy/blob/master/python/python-gst-player-example.py

这个例子不能直接运行，需要根据具体情况，略作修改，修改的地方如下：

1）self.uri存放用于播放的媒体文件的URI，注意这里是URI，而不是普通的路径，如果要指定本地文件的话，需要使用`file://`。

2)出错的时候，先用`gst-inspect`检查一下，相应的插件是否安装好了。

## Step 1——添加暂停和进度条控制功能

代码参见：

https://github.com/antkillerfarm/antkillerfarm_crazy/blob/master/gstreamer/step1/my-gst-player.py

